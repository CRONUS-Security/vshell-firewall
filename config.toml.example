# vshell-firewall 配置文件示例
# 复制此文件为 config.toml 并根据需要修改

# 全局配置
[global]
buffer_size = 32768  # 缓冲区大小 (字节)
log_level = "info"   # 日志级别: debug, info, warn, error

# 监听端口配置 - 可以配置多个
[[listeners]]
name = "http_proxy"           # 监听器名称
listen_port = ":8880"         # 监听端口
backend_addr = "127.0.0.1:9991"  # 后端地址
protocol = "auto"             # 协议类型: auto (自动检测), http, tcp

# 超时配置
[listeners.timeout]
enabled = true                # 是否启用超时
initial_read = 30             # 初始读取超时 (秒)，0 表示无限制
connect_backend = 5           # 连接后端超时 (秒)，0 表示无限制

# 路由规则 - 按顺序匹配
[[listeners.routes]]
path = "/patch_slt"           # 路径匹配 (支持前缀匹配)
action = "allow"              # 动作: drop (拒绝), allow (允许)
rewrite_to = "/slt"           # 路径重写目标 (可选，将 /patch_slt 重写为 /slt)

[[listeners.routes]]
path = "/slt"                 # 路径匹配
action = "drop"               # 拒绝访问
response = "404"              # drop 时的响应: 404, 403, 502, close (直接关闭)

[[listeners.routes]]
path = "/admin"
action = "drop"
response = "403"

[[listeners.routes]]
path = "/"                    # 默认规则，匹配所有
action = "allow"


# 第二个监听器示例 - 纯 TCP 转发，无超时限制
[[listeners]]
name = "tcp_longconn"
listen_port = ":9880"
backend_addr = "127.0.0.1:9992"
protocol = "tcp"              # 强制 TCP 模式，不检测 HTTP

[listeners.timeout]
enabled = false               # 禁用超时，适合长连接

[[listeners.routes]]
path = "/"
action = "allow"


# 第三个监听器示例 - HTTP 反向代理
[[listeners]]
name = "api_proxy"
listen_port = ":7880"
backend_addr = "127.0.0.1:8000"
protocol = "http"             # 强制 HTTP 模式

[listeners.timeout]
enabled = true
initial_read = 60
connect_backend = 10

# 复杂的路由规则
[[listeners.routes]]
path = "/api/internal"        # 阻止内部 API 访问
action = "drop"
response = "403"

[[listeners.routes]]
path = "/api/admin"
action = "drop"
response = "404"

[[listeners.routes]]
path = "/health"              # 健康检查允许
action = "allow"

[[listeners.routes]]
path = "/api"                 # 其他 API 允许
action = "allow"

[[listeners.routes]]
path = "/"                    # 其他路径拒绝
action = "drop"
response = "404"
